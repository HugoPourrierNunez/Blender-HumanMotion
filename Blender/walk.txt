import bpy
import math

ampVert = 1
ampHoriz = 1
freq = 0.2
ampSpine = 0.1

a=0.2
b=0.05
avancement=0.1
nbFrame=50
vitesse=5

ob = bpy.data.objects['rig']
bpy.context.scene.objects.active = ob
bpy.ops.object.mode_set(mode='POSE')

pbone = ob.pose.bones['spine1']
rl = ob.pose.bones['rightLegIK']
ll = ob.pose.bones['leftLegIK']
ra = ob.pose.bones['rightArmIK']
la = ob.pose.bones['leftArmIK']
c=ob.pose.bones['control']
# Set rotation mode to Euler XYZ, easier to understand
# than default quaternions
#pbone.rotation_mode = 'XYZ'
# select axis in ['X','Y','Z']  <--bone local
#axis = 'Z'
#angle = 120
#pbone.rotation_euler.rotate_axis(axis, -0.5)

#pbone.transform.translate(value=(1,0,0))





#bpy.ops.object.mode_set(mode='OBJECT')
#insert a keyframe


#pbone.keyframe_insert(data_path="rotation_euler" ,frame=1)




for framee in range(0,int(nbFrame)):
    pbone.location=(avancement,ampSpine*math.fabs(math.sin(freq*framee)),0)
    pbone.keyframe_insert(data_path="location" ,frame=framee)
    vertCoord1 = 0 if math.sin(freq*framee) < 0 else math.sin(freq*framee)
    vertCoord2 = 0 if -math.sin(freq*framee) < 0 else math.sin(freq*framee)
    c.location=(0,float(framee)/nbFrame*vitesse,0)
    c.keyframe_insert(data_path="location" ,frame=framee)
    rl.location=(0,ampHoriz*math.cos(freq*framee),ampVert*vertCoord1)
    rl.keyframe_insert(data_path="location" ,frame=framee)
    ll.location=(0,ampHoriz*math.cos(freq*framee+3.14),ampVert*vertCoord2)
    ll.keyframe_insert(data_path="location" ,frame=framee)
    la.location=(0,ampHoriz*math.cos(freq*framee)-a/2,ampVert*vertCoord1)
    la.keyframe_insert(data_path="location" ,frame=framee)
    ra.location=(0,ampHoriz*math.cos(freq*framee+3.14)-ampHoriz,ampVert*vertCoord2)
    ra.keyframe_insert(data_path="location" ,frame=framee)
    
    
    